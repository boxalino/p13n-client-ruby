#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module DateRangeGap
  SECOND = 1
  MINUTE = 2
  HOUR = 3
  DAY = 4
  WEEK = 5
  MONTH = 6
  YEAR = 7
  DECADE = 8
  CENTURY = 9
  VALUE_MAP = {1 => "SECOND", 2 => "MINUTE", 3 => "HOUR", 4 => "DAY", 5 => "WEEK", 6 => "MONTH", 7 => "YEAR", 8 => "DECADE", 9 => "CENTURY"}
  VALID_VALUES = Set.new([SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, YEAR, DECADE, CENTURY]).freeze
end

module FacetSortOrder
  POPULATION = 1
  COLLATION = 2
  VALUE_MAP = {1 => "POPULATION", 2 => "COLLATION"}
  VALID_VALUES = Set.new([POPULATION, COLLATION]).freeze
end

# Filter to be used in query. Note that type of generated filter depends on first non-null and non-empty value in order of preference. Values of lower priority are ignored:
# stringValues!=null && simpleValues.size()>0 => simple match, prefix!=null => prefix match, hierarchy!=null && hierarchy.size()>0 => hierarchy filter, else range filter
# 
# <dl>
# <dt>negative</dt>
# <dd>whether the filter is negative (boolean NOT)</dd>
# 
# <dt>fieldName</dt>
# <dd>field name to apply filter to</dd>
# 
# <dt>stringValues</dt>
# <dd>values for simple match</dd>
# 
# <dt>prefix</dt>
# <dd>prefix match</dd>
# 
# <dt>hierarchyId</dt>
# <dd>hierarchy filter - when corresponding hierarchical field has encoded id</dd>
# 
# <dt>hierarchy</dt>
# <dd>hierarchy filter - for example categories path in top-down order</dd>
# 
# <dt>rangeFrom</dt>
# <dd>lower bound for range filter</dd>
# 
# <dt>rangeFromInclusive</dt>
# <dd>whether the lower bound is inclusive</dd>
# 
# <dt>rangeTo</dt>
# <dd>upper bound for range filter</dd>
# 
# <dt>rangeToInclusive</dt>
# <dd>whether the upper bound is inclusive</dd>
# </dl>
class Filter
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NEGATIVE = 1
  FIELDNAME = 2
  STRINGVALUES = 3
  PREFIX = 4
  HIERARCHYID = 41
  HIERARCHY = 5
  RANGEFROM = 6
  RANGEFROMINCLUSIVE = 7
  RANGETO = 8
  RANGETOINCLUSIVE = 9

  FIELDS = {
    NEGATIVE => {:type => ::Thrift::Types::BOOL, :name => 'negative'},
    FIELDNAME => {:type => ::Thrift::Types::STRING, :name => 'fieldName'},
    STRINGVALUES => {:type => ::Thrift::Types::LIST, :name => 'stringValues', :element => {:type => ::Thrift::Types::STRING}},
    PREFIX => {:type => ::Thrift::Types::STRING, :name => 'prefix'},
    HIERARCHYID => {:type => ::Thrift::Types::STRING, :name => 'hierarchyId'},
    HIERARCHY => {:type => ::Thrift::Types::LIST, :name => 'hierarchy', :element => {:type => ::Thrift::Types::STRING}},
    RANGEFROM => {:type => ::Thrift::Types::STRING, :name => 'rangeFrom'},
    RANGEFROMINCLUSIVE => {:type => ::Thrift::Types::BOOL, :name => 'rangeFromInclusive'},
    RANGETO => {:type => ::Thrift::Types::STRING, :name => 'rangeTo'},
    RANGETOINCLUSIVE => {:type => ::Thrift::Types::BOOL, :name => 'rangeToInclusive'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>stringValue</dt>
# <dd>corresponding value of the facet</dd>
# 
# <dt>rangeFromInclusive</dt>
# <dd>if range facets lower bound (inclusive)</dd>
# 
# <dt>rangeToExclusive</dt>
# <dd>if range facets upper bound (inclusive)</dd>
# 
# <dt>hitCount</dt>
# <dd>number of hits found</dd>
# 
# <dt>hierarchyId</dt>
# <dd>id of hierarchy if corresponding field is hierarchical</dd>
# 
# <dt>hierarchy</dt>
# <dd>hierarchy if corresponding field is hierarchical</dd>
# 
# <dt>selected</dt>
# <dd>whether the facet value has been selected in corresponding FacetRequest</dd>
# </dl>
class FacetValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  STRINGVALUE = 1
  RANGEFROMINCLUSIVE = 2
  RANGETOEXCLUSIVE = 3
  HITCOUNT = 4
  HIERARCHYID = 50
  HIERARCHY = 60
  SELECTED = 70

  FIELDS = {
    STRINGVALUE => {:type => ::Thrift::Types::STRING, :name => 'stringValue'},
    RANGEFROMINCLUSIVE => {:type => ::Thrift::Types::STRING, :name => 'rangeFromInclusive'},
    RANGETOEXCLUSIVE => {:type => ::Thrift::Types::STRING, :name => 'rangeToExclusive'},
    HITCOUNT => {:type => ::Thrift::Types::I64, :name => 'hitCount'},
    HIERARCHYID => {:type => ::Thrift::Types::STRING, :name => 'hierarchyId'},
    HIERARCHY => {:type => ::Thrift::Types::LIST, :name => 'hierarchy', :element => {:type => ::Thrift::Types::STRING}},
    SELECTED => {:type => ::Thrift::Types::BOOL, :name => 'selected'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>fieldName</dt>
# <dd>name of the field to get facet for</dd>
# 
# <dt>numerical</dt>
# <dd>whether the facet is numerical</dd>
# 
# <dt>range</dt>
# <dd>whether the facet is range facet</dd>
# 
# <dt>maxCount</dt>
# <dd>maximum number of facets to return by given order, -1 for all of them</dd>
# 
# <dt>minPopulation</dt>
# <dd>minimum facet population to return</dd>
# 
# <dt>dateRangeGap</dt>
# <dd>if the corresponding field is date then the gap to be used for facet</dd>
# 
# <dt>sortOrder</dt>
# <dd>sort order</dd>
# 
# <dt>sortAscending</dt>
# <dd>whether the sort should be done ascending</dd>
# 
# <dt>selectedValues</dt>
# <dd>values selected from the facet.</dd>
# <dd>Note that results will be filtered by these values, but the corresponding
# FacetResponse is as if this filter was not applied</dd>
# 
# <dt>andSelectedValues</dt>
# <dd>whether selectedValues should be considered in AND logic, meaning filter
# out those that don't contain ALL selected values - default is OR - include
# those contianing any of selectedValue</dd>
# 
# <dt>boundsOnly</dt>
# <dd>only affects numeric range facets. will always return one FacetValue with rangeFromInclusive and rangeToExclusive
# set according to the actual minimum and maximum value</dd>
# </dl>
class FacetRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDNAME = 1
  NUMERICAL = 2
  RANGE = 3
  MAXCOUNT = 4
  MINPOPULATION = 5
  DATERANGEGAP = 6
  SORTORDER = 7
  SORTASCENDING = 8
  SELECTEDVALUES = 90
  ANDSELECTEDVALUES = 100
  BOUNDSONLY = 110

  FIELDS = {
    FIELDNAME => {:type => ::Thrift::Types::STRING, :name => 'fieldName'},
    NUMERICAL => {:type => ::Thrift::Types::BOOL, :name => 'numerical'},
    RANGE => {:type => ::Thrift::Types::BOOL, :name => 'range'},
    MAXCOUNT => {:type => ::Thrift::Types::I32, :name => 'maxCount', :default => -1},
    MINPOPULATION => {:type => ::Thrift::Types::I32, :name => 'minPopulation', :default => 1},
    DATERANGEGAP => {:type => ::Thrift::Types::I32, :name => 'dateRangeGap', :enum_class => ::DateRangeGap},
    SORTORDER => {:type => ::Thrift::Types::I32, :name => 'sortOrder', :enum_class => ::FacetSortOrder},
    SORTASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'sortAscending'},
    SELECTEDVALUES => {:type => ::Thrift::Types::LIST, :name => 'selectedValues', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FacetValue}},
    ANDSELECTEDVALUES => {:type => ::Thrift::Types::BOOL, :name => 'andSelectedValues', :default => false},
    BOUNDSONLY => {:type => ::Thrift::Types::BOOL, :name => 'boundsOnly', :default => false}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @dateRangeGap.nil? || ::DateRangeGap::VALID_VALUES.include?(@dateRangeGap)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field dateRangeGap!')
    end
    unless @sortOrder.nil? || ::FacetSortOrder::VALID_VALUES.include?(@sortOrder)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field sortOrder!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# field to be used for sorting
class SortField
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDNAME = 1
  REVERSE = 2

  FIELDS = {
    FIELDNAME => {:type => ::Thrift::Types::STRING, :name => 'fieldName'},
    REVERSE => {:type => ::Thrift::Types::BOOL, :name => 'reverse'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>indexId</dt>
# <dd>indexId to be used for search</dd>
# 
# <dt>language</dt>
# <dd>language for localization</dd>
# 
# <dt>queryText</dt>
# <dd>main search query</dd>
# 
# <dt>filters</dt>
# <dd>list of filters to apply</dd>
# 
# <dt>orFilters</dt>
# <dd>whether boolean OR should be aplied to the given list of filters if false
# boolean AND will be applied</dd>
# 
# <dt>facetRequests</dt>
# <dd>list of facets to be returned</dd>
# 
# <dt>sortFields</dt>
# <dd>optional list of sort fields for hardcoded sorting. If not given,
# relevance sort order will be used</dd>
# 
# <dt>offset</dt>
# <dd>from which hit to return result</dd>
# 
# <dt>hitCount</dt>
# <dd>how many hits to return</dd>
# 
# <dt>returnFields</dt>
# <dd>which index fields to be returned</dd>
# 
# <dt>groupBy</dt>
# <dd>field name of the field to do grouping by</dd>
# 
# <dt>groupFacets</dt>
# <dd>whether facets counts should contain number of groups</dd>
# 
# <dt>groupItemsCount</dt>
# <dd>how many hits in each group to return</dd>
# 
# <dt>groupItemsSort</dt>
# <dd>how to sort items within the group, default is score</dd>
# 
# <dt>groupItemsSortAscending</dt>
# <dd>whether to sort items within the group ascending</dd>
# 
# <dt>hitsGroupsAsHits</dt>
# <dd>if true, will return hitsGroups as hits in the response</dd>
# </dl>
class SimpleSearchQuery
  include ::Thrift::Struct, ::Thrift::Struct_Union
  INDEXID = 1
  LANGUAGE = 2
  QUERYTEXT = 3
  FILTERS = 4
  ORFILTERS = 5
  FACETREQUESTS = 6
  SORTFIELDS = 7
  OFFSET = 8
  HITCOUNT = 9
  RETURNFIELDS = 10
  GROUPBY = 20
  GROUPFACETS = 30
  GROUPITEMSCOUNT = 40
  GROUPITEMSSORT = 50
  GROUPITEMSSORTASCENDING = 60
  HITSGROUPSASHITS = 70

  FIELDS = {
    INDEXID => {:type => ::Thrift::Types::STRING, :name => 'indexId'},
    LANGUAGE => {:type => ::Thrift::Types::STRING, :name => 'language'},
    QUERYTEXT => {:type => ::Thrift::Types::STRING, :name => 'queryText'},
    FILTERS => {:type => ::Thrift::Types::LIST, :name => 'filters', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Filter}},
    ORFILTERS => {:type => ::Thrift::Types::BOOL, :name => 'orFilters'},
    FACETREQUESTS => {:type => ::Thrift::Types::LIST, :name => 'facetRequests', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FacetRequest}},
    SORTFIELDS => {:type => ::Thrift::Types::LIST, :name => 'sortFields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SortField}},
    OFFSET => {:type => ::Thrift::Types::I64, :name => 'offset'},
    HITCOUNT => {:type => ::Thrift::Types::I32, :name => 'hitCount'},
    RETURNFIELDS => {:type => ::Thrift::Types::LIST, :name => 'returnFields', :element => {:type => ::Thrift::Types::STRING}},
    GROUPBY => {:type => ::Thrift::Types::STRING, :name => 'groupBy'},
    GROUPFACETS => {:type => ::Thrift::Types::BOOL, :name => 'groupFacets', :default => true},
    GROUPITEMSCOUNT => {:type => ::Thrift::Types::I32, :name => 'groupItemsCount', :default => 1},
    GROUPITEMSSORT => {:type => ::Thrift::Types::STRING, :name => 'groupItemsSort', :default => %q"score"},
    GROUPITEMSSORTASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'groupItemsSortAscending', :default => false},
    HITSGROUPSASHITS => {:type => ::Thrift::Types::BOOL, :name => 'hitsGroupsAsHits', :default => false}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>indexId</dt>
# <dd>id of the index to fetch context item data from</dd>
# 
# <dt>fieldName</dt>
# <dd>the field name of the item's unique identifier within the items index</dd>
# <dd>for example: 'sku' for items 'products'</dd>
# 
# <dt>contextItemId</dt>
# <dd>actual item's identifier</dd>
# <dd>for example: actual sku of the product</dd>
# 
# <dt>role</dt>
# <dd>role of the item within the context, used to address the item in the
# recommendation script.</dd>
# <dd>for example: 'main product' for recommendations within product detail
# page</dd>
# </dl>
class ContextItem
  include ::Thrift::Struct, ::Thrift::Struct_Union
  INDEXID = 1
  FIELDNAME = 2
  CONTEXTITEMID = 3
  ROLE = 4

  FIELDS = {
    INDEXID => {:type => ::Thrift::Types::STRING, :name => 'indexId'},
    FIELDNAME => {:type => ::Thrift::Types::STRING, :name => 'fieldName'},
    CONTEXTITEMID => {:type => ::Thrift::Types::STRING, :name => 'contextItemId'},
    ROLE => {:type => ::Thrift::Types::STRING, :name => 'role'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>choiceId</dt>
# <dd>personalization choice identificator</dd>
# 
# <dt>simpleSearchQuery</dt>
# <dd>search query in a case of recommendation and search inquiries</dd>
# 
# <dt>contextItems</dt>
# <dd>context items for recommendations</dd>
# 
# <dt>minHitCount</dt>
# <dd>minimal hit count to return for recommendations.</dd>
# <dd>if higher priority recommendation strategy yields less results, next
# strategy is tried</dd>
# 
# <dt>excludeVariantIds</dt>
# <dd>set of variantIds to be excluded from result, has no effect if null or empty</dd>
# 
# <dt>includeVariantIds</dt>
# <dd>set of variantIds to be included in the result, has no effect if null or empty</dd>
# 
# <dt>scope</dt>
# <dd>choice source to be used</dd>
# 
# <dt>withRelaxation</dt>
# <dd>if search relaxation should be used</dd>
# </dl>
class ChoiceInquiry
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CHOICEID = 1
  SIMPLESEARCHQUERY = 2
  CONTEXTITEMS = 3
  MINHITCOUNT = 4
  EXCLUDEVARIANTIDS = 5
  SCOPE = 6
  WITHRELAXATION = 70
  WITHSEMANTICFILTERING = 80
  INCLUDEVARIANTIDS = 90

  FIELDS = {
    CHOICEID => {:type => ::Thrift::Types::STRING, :name => 'choiceId'},
    SIMPLESEARCHQUERY => {:type => ::Thrift::Types::STRUCT, :name => 'simpleSearchQuery', :class => ::SimpleSearchQuery},
    CONTEXTITEMS => {:type => ::Thrift::Types::LIST, :name => 'contextItems', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ContextItem}},
    MINHITCOUNT => {:type => ::Thrift::Types::I32, :name => 'minHitCount'},
    EXCLUDEVARIANTIDS => {:type => ::Thrift::Types::SET, :name => 'excludeVariantIds', :element => {:type => ::Thrift::Types::STRING}},
    SCOPE => {:type => ::Thrift::Types::STRING, :name => 'scope', :default => %q"system_rec"},
    WITHRELAXATION => {:type => ::Thrift::Types::BOOL, :name => 'withRelaxation', :default => false},
    WITHSEMANTICFILTERING => {:type => ::Thrift::Types::BOOL, :name => 'withSemanticFiltering', :default => false},
    INCLUDEVARIANTIDS => {:type => ::Thrift::Types::SET, :name => 'includeVariantIds', :element => {:type => ::Thrift::Types::STRING}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# parameters of request context. Usually browser, platform, etc.
class RequestContext
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PARAMETERS = 1

  FIELDS = {
    PARAMETERS => {:type => ::Thrift::Types::MAP, :name => 'parameters', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# unique identifier of the customer
class UserRecord
  include ::Thrift::Struct, ::Thrift::Struct_Union
  USERNAME = 1
  APIKEY = 10
  APISECRET = 20

  FIELDS = {
    USERNAME => {:type => ::Thrift::Types::STRING, :name => 'username'},
    APIKEY => {:type => ::Thrift::Types::STRING, :name => 'apiKey'},
    APISECRET => {:type => ::Thrift::Types::STRING, :name => 'apiSecret'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>profileId</dt>
# <dd>profile (visitor) identificator</dd>
# 
# <dt>inquiries</dt>
# <dd>list of inquiries to be executed sequentially.</dd>
# <dd>Inquiries with higher index may depend from those with lower index.</dd>
# 
# <dt>requestContext</dt>
# <dd>context of the request</dd>
# </dl>
class ChoiceRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  USERRECORD = 1
  PROFILEID = 2
  INQUIRIES = 3
  REQUESTCONTEXT = 4

  FIELDS = {
    USERRECORD => {:type => ::Thrift::Types::STRUCT, :name => 'userRecord', :class => ::UserRecord},
    PROFILEID => {:type => ::Thrift::Types::STRING, :name => 'profileId'},
    INQUIRIES => {:type => ::Thrift::Types::LIST, :name => 'inquiries', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ChoiceInquiry}},
    REQUESTCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'requestContext', :class => ::RequestContext}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>fieldName</dt>
# <dd>name of the facet field</dd>
# 
# <dt>values</dt>
# <dd>list of facet values</dd>
# </dl>
class FacetResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FIELDNAME = 1
  VALUES = 2

  FIELDS = {
    FIELDNAME => {:type => ::Thrift::Types::STRING, :name => 'fieldName'},
    VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FacetValue}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# item found
# 
# <dl>
# <dt>values</dt>
# <dd>map containing name of the field and list of values as strings</dd>
# <dd>if index contains no value for a field, empty array will be returned.</dd>
# 
# <dt>score</dt>
# <dd>index score of the hit</dd>
# 
# <dt>scenarioId</dt>
# <dd>source scenarioId in case of mixed recommendations modes</dd>
# </dl>
class Hit
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUES = 1
  SCORE = 2
  SCENARIOID = 30

  FIELDS = {
    VALUES => {:type => ::Thrift::Types::MAP, :name => 'values', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRING}}},
    SCORE => {:type => ::Thrift::Types::DOUBLE, :name => 'score'},
    SCENARIOID => {:type => ::Thrift::Types::STRING, :name => 'scenarioId'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# grouped item found
# 
# <dl>
# <dt>groupValue</dt>
# <dd>value of the groupBy field</dd>
# 
# <dt>totalHitCount</dt>
# <dd>total hits count within the group</dd>
# 
# <dt>hits</dt>
# <dd>group hits</dd>
# </dl>
class HitsGroup
  include ::Thrift::Struct, ::Thrift::Struct_Union
  GROUPVALUE = 10
  TOTALHITCOUNT = 20
  HITS = 30

  FIELDS = {
    GROUPVALUE => {:type => ::Thrift::Types::STRING, :name => 'groupValue'},
    TOTALHITCOUNT => {:type => ::Thrift::Types::I64, :name => 'totalHitCount'},
    HITS => {:type => ::Thrift::Types::LIST, :name => 'hits', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Hit}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>hits</dt>
# <dd>list of hits found for given SimpleSearchQuery</dd>
# 
# <dt>facetResponses</dt>
# <dd>list of requested facets or null if none requested</dd>
# 
# <dt>totalHitCount</dt>
# <dd>total number of hits; -1 in case of mixed recommendation strategy</dd>
# 
# <dt>queryText</dt>
# <dd>relaxation query text for relaxation results or requested queryText for a
# regular SearchResult</dd>
# 
# <dt>hitsGroups</dt>
# <dd>grouped hits; not null when corresponding SimplSearchQuery has
# groupBy!=null </dd>
# </dl>
class SearchResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  HITS = 1
  FACETRESPONSES = 2
  TOTALHITCOUNT = 3
  QUERYTEXT = 40
  HITSGROUPS = 50

  FIELDS = {
    HITS => {:type => ::Thrift::Types::LIST, :name => 'hits', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Hit}},
    FACETRESPONSES => {:type => ::Thrift::Types::LIST, :name => 'facetResponses', :element => {:type => ::Thrift::Types::STRUCT, :class => ::FacetResponse}},
    TOTALHITCOUNT => {:type => ::Thrift::Types::I64, :name => 'totalHitCount'},
    QUERYTEXT => {:type => ::Thrift::Types::STRING, :name => 'queryText'},
    HITSGROUPS => {:type => ::Thrift::Types::LIST, :name => 'hitsGroups', :element => {:type => ::Thrift::Types::STRUCT, :class => ::HitsGroup}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class SearchRelaxation
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SUGGESTIONSRESULTS = 10
  SUBPHRASESRESULTS = 20

  FIELDS = {
    SUGGESTIONSRESULTS => {:type => ::Thrift::Types::LIST, :name => 'suggestionsResults', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SearchResult}},
    SUBPHRASESRESULTS => {:type => ::Thrift::Types::LIST, :name => 'subphrasesResults', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SearchResult}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>variantId</dt>
# <dd>id of the personalized variant</dd>
# 
# <dt>scenarioId</dt>
# <dd>scenario identificator used to produce recommendation result or search
# result personalization</dd>
# 
# <dt>searchResult</dt>
# <dd>result of the search request for recommendations and search requests</dd>
# 
# <dt>searchResultTitle</dt>
# <dd>recommendation's result title localized in language requested in
# corresponding SimpleSearchQuery</dd>
# 
# <dt>searchRelaxation</dt>
# <dd>When the service considers queryText invalid, it will evaluate and return
# relaxations if it is requested in corresponding ChoiceInquiry and if
# relaxations could be found.</dd>
# <dd>Note that original query still could yield some results; it is up to the
# client to decide whether searchRelaxations should be used (with displaying
# appropriate message) or not.</dd>
# </dl>
class Variant
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VARIANTID = 1
  SCENARIOID = 2
  SEARCHRESULT = 3
  SEARCHRESULTTITLE = 4
  SEARCHRELAXATION = 50
  SEMANTICFILTERINGRESULTS = 60

  FIELDS = {
    VARIANTID => {:type => ::Thrift::Types::STRING, :name => 'variantId'},
    SCENARIOID => {:type => ::Thrift::Types::STRING, :name => 'scenarioId'},
    SEARCHRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'searchResult', :class => ::SearchResult},
    SEARCHRESULTTITLE => {:type => ::Thrift::Types::STRING, :name => 'searchResultTitle'},
    SEARCHRELAXATION => {:type => ::Thrift::Types::STRUCT, :name => 'searchRelaxation', :class => ::SearchRelaxation},
    SEMANTICFILTERINGRESULTS => {:type => ::Thrift::Types::LIST, :name => 'semanticFilteringResults', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SearchResult}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# list of personalized variants. Item's index corresponds to the index of the
# ChoiceInquiry
class ChoiceResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VARIANTS = 1

  FIELDS = {
    VARIANTS => {:type => ::Thrift::Types::LIST, :name => 'variants', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Variant}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ProfilePropertyValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PROFILEID = 1
  PROPERTYNAME = 2
  PROPERTYVALUE = 3
  CONFIDENCE = 4

  FIELDS = {
    PROFILEID => {:type => ::Thrift::Types::STRING, :name => 'profileId'},
    PROPERTYNAME => {:type => ::Thrift::Types::STRING, :name => 'propertyName'},
    PROPERTYVALUE => {:type => ::Thrift::Types::STRING, :name => 'propertyValue'},
    CONFIDENCE => {:type => ::Thrift::Types::I32, :name => 'confidence'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ProfileContext
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PROFILEID = 1
  REQUESTCONTEXT = 2

  FIELDS = {
    PROFILEID => {:type => ::Thrift::Types::STRING, :name => 'profileId'},
    REQUESTCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'requestContext', :class => ::RequestContext}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>choiceInquiry</dt>
# <dd><b>deprecated</b> - use choiceInquiries instead.</dd>
# <dd>If choiceInquiries is given this field will be ignored</dd>
# 
# <dt>choiceInquiries</dt>
# <dd>list of ChoiceInquiries to be executed sequentially.</dd>
# <dd>Note that list items can depend of items before in list</dd>
# 
# <dt>requestContext</dt>
# <dd><b>deprecated</b> - use profileContexts instead.</dd>
# 
# <dt>profileIds</dt>
# <dd><b>deprecated</b> - use profileContexts instead.</dd>
# </dl>
class BatchChoiceRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  USERRECORD = 1
  CHOICEINQUIRY = 2
  REQUESTCONTEXT = 3
  PROFILEIDS = 4
  CHOICEINQUIRIES = 5
  PROFILECONTEXTS = 6

  FIELDS = {
    USERRECORD => {:type => ::Thrift::Types::STRUCT, :name => 'userRecord', :class => ::UserRecord},
    CHOICEINQUIRY => {:type => ::Thrift::Types::STRUCT, :name => 'choiceInquiry', :class => ::ChoiceInquiry},
    REQUESTCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'requestContext', :class => ::RequestContext},
    PROFILEIDS => {:type => ::Thrift::Types::LIST, :name => 'profileIds', :element => {:type => ::Thrift::Types::STRING}},
    CHOICEINQUIRIES => {:type => ::Thrift::Types::LIST, :name => 'choiceInquiries', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ChoiceInquiry}},
    PROFILECONTEXTS => {:type => ::Thrift::Types::LIST, :name => 'profileContexts', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ProfileContext}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# <dl>
# <dt>variants</dt>
# <dd><b>deprecated</b> - contains non-null value only if
# corresponding BatchChoiceRequest had only one ChoiceInquiry</dd>
# 
# <dt>selectedVariants</dt>
# <dd>outer list corresponds to profileIds given in BatchChoiceRequest, while
# inner list corresponds to list of ChoiceInquiries from BatchChoiceRequest</dd>
# </dl>
class BatchChoiceResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VARIANTS = 1
  SELECTEDVARIANTS = 2

  FIELDS = {
    VARIANTS => {:type => ::Thrift::Types::LIST, :name => 'variants', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Variant}},
    SELECTEDVARIANTS => {:type => ::Thrift::Types::LIST, :name => 'selectedVariants', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRUCT, :class => ::Variant}}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AutocompleteHit
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SUGGESTION = 11
  HIGHLIGHTED = 21
  SEARCHRESULT = 31
  SCORE = 41

  FIELDS = {
    SUGGESTION => {:type => ::Thrift::Types::STRING, :name => 'suggestion'},
    HIGHLIGHTED => {:type => ::Thrift::Types::STRING, :name => 'highlighted'},
    SEARCHRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'searchResult', :class => ::SearchResult},
    SCORE => {:type => ::Thrift::Types::DOUBLE, :name => 'score'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AutocompleteQuery
  include ::Thrift::Struct, ::Thrift::Struct_Union
  INDEXID = 11
  LANGUAGE = 21
  QUERYTEXT = 31
  SUGGESTIONSHITCOUNT = 41
  HIGHLIGHT = 51
  HIGHLIGHTPRE = 61
  HIGHLIGHTPOST = 71

  FIELDS = {
    INDEXID => {:type => ::Thrift::Types::STRING, :name => 'indexId'},
    LANGUAGE => {:type => ::Thrift::Types::STRING, :name => 'language'},
    QUERYTEXT => {:type => ::Thrift::Types::STRING, :name => 'queryText'},
    SUGGESTIONSHITCOUNT => {:type => ::Thrift::Types::I32, :name => 'suggestionsHitCount'},
    HIGHLIGHT => {:type => ::Thrift::Types::BOOL, :name => 'highlight'},
    HIGHLIGHTPRE => {:type => ::Thrift::Types::STRING, :name => 'highlightPre', :default => %q"<em>"},
    HIGHLIGHTPOST => {:type => ::Thrift::Types::STRING, :name => 'highlightPost', :default => %q"</em>"}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AutocompleteRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  USERRECORD = 11
  SCOPE = 21
  CHOICEID = 31
  PROFILEID = 41
  REQUESTCONTEXT = 51
  EXCLUDEVARIANTIDS = 61
  AUTOCOMPLETEQUERY = 71
  SEARCHCHOICEID = 81
  SEARCHQUERY = 91
  INCLUDEVARIANTIDS = 101
  PROPERTYQUERIES = 110

  FIELDS = {
    USERRECORD => {:type => ::Thrift::Types::STRUCT, :name => 'userRecord', :class => ::UserRecord},
    SCOPE => {:type => ::Thrift::Types::STRING, :name => 'scope', :default => %q"system_rec"},
    CHOICEID => {:type => ::Thrift::Types::STRING, :name => 'choiceId'},
    PROFILEID => {:type => ::Thrift::Types::STRING, :name => 'profileId'},
    REQUESTCONTEXT => {:type => ::Thrift::Types::STRUCT, :name => 'requestContext', :class => ::RequestContext},
    EXCLUDEVARIANTIDS => {:type => ::Thrift::Types::SET, :name => 'excludeVariantIds', :element => {:type => ::Thrift::Types::STRING}},
    AUTOCOMPLETEQUERY => {:type => ::Thrift::Types::STRUCT, :name => 'autocompleteQuery', :class => ::AutocompleteQuery},
    SEARCHCHOICEID => {:type => ::Thrift::Types::STRING, :name => 'searchChoiceId'},
    SEARCHQUERY => {:type => ::Thrift::Types::STRUCT, :name => 'searchQuery', :class => ::SimpleSearchQuery},
    INCLUDEVARIANTIDS => {:type => ::Thrift::Types::SET, :name => 'includeVariantIds', :element => {:type => ::Thrift::Types::STRING}},
    PROPERTYQUERIES => {:type => ::Thrift::Types::LIST, :name => 'propertyQueries', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PropertyQuery}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PropertyQuery
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 11
  HITCOUNT = 21
  EVALUATETOTAL = 31

  FIELDS = {
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    HITCOUNT => {:type => ::Thrift::Types::I32, :name => 'hitCount'},
    EVALUATETOTAL => {:type => ::Thrift::Types::BOOL, :name => 'evaluateTotal'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PropertyResult
  include ::Thrift::Struct, ::Thrift::Struct_Union
  HITS = 11
  NAME = 21

  FIELDS = {
    HITS => {:type => ::Thrift::Types::LIST, :name => 'hits', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PropertyHit}},
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class PropertyHit
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VALUE = 11
  LABEL = 21
  TOTALHITCOUNT = 31

  FIELDS = {
    VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'},
    LABEL => {:type => ::Thrift::Types::STRING, :name => 'label'},
    TOTALHITCOUNT => {:type => ::Thrift::Types::I64, :name => 'totalHitCount'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AutocompleteResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  HITS = 11
  PREFIXSEARCHRESULT = 21
  PROPERTYRESULTS = 31

  FIELDS = {
    HITS => {:type => ::Thrift::Types::LIST, :name => 'hits', :element => {:type => ::Thrift::Types::STRUCT, :class => ::AutocompleteHit}},
    PREFIXSEARCHRESULT => {:type => ::Thrift::Types::STRUCT, :name => 'prefixSearchResult', :class => ::SearchResult},
    PROPERTYRESULTS => {:type => ::Thrift::Types::LIST, :name => 'propertyResults', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PropertyResult}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AutocompleteRequestBundle
  include ::Thrift::Struct, ::Thrift::Struct_Union
  REQUESTS = 11

  FIELDS = {
    REQUESTS => {:type => ::Thrift::Types::LIST, :name => 'requests', :element => {:type => ::Thrift::Types::STRUCT, :class => ::AutocompleteRequest}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AutocompleteResponseBundle
  include ::Thrift::Struct, ::Thrift::Struct_Union
  RESPONSES = 11

  FIELDS = {
    RESPONSES => {:type => ::Thrift::Types::LIST, :name => 'responses', :element => {:type => ::Thrift::Types::STRUCT, :class => ::AutocompleteResponse}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# Request object for changing the choice, that is changing possible variants
# or their random distribution
class ChoiceUpdateRequest
  include ::Thrift::Struct, ::Thrift::Struct_Union
  USERRECORD = 11
  CHOICEID = 21
  VARIANTIDS = 31

  FIELDS = {
    # user record identifying the client
    USERRECORD => {:type => ::Thrift::Types::STRUCT, :name => 'userRecord', :class => ::UserRecord},
    # Identifier of the choice to be changed. If it is not given, a new choice will be created
    CHOICEID => {:type => ::Thrift::Types::STRING, :name => 'choiceId'},
    # Map containing variant identifier and corresponding positive integer weight.
# If for a choice there is no learned rule which can be applied, weights of
# variants will be used for variants random distribution.
# Higher weight makes corresponding variant more probable.
    VARIANTIDS => {:type => ::Thrift::Types::MAP, :name => 'variantIds', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# Server response for one ChoiceUpdateRequest
class ChoiceUpdateResponse
  include ::Thrift::Struct, ::Thrift::Struct_Union
  CHOICEID = 11

  FIELDS = {
    # Identifier of the changed choice. If no id is given in corresponding
# ChoiceUpdateRequest, new choice (and new id) will be created and retuned.
    CHOICEID => {:type => ::Thrift::Types::STRING, :name => 'choiceId'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class P13nServiceException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.message = message
  end

  MESSAGE = 1

  FIELDS = {
    MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field message is unset!') unless @message
  end

  ::Thrift::Struct.generate_accessors self
end

